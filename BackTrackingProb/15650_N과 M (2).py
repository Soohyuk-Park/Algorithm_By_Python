# https://www.acmicpc.net/status?user_id=homeomor997&problem_id=15650&from_mine=1 #
# 백트랙킹 문제입니다. N과 M (1)에서 했던 코드중에서. 새로운 숫자 추가에 대한 조건만 새로 추가해주면 쉽게 풀리는 문제.

n, m = list(map(int, input().split()))

s = []


def dfs():
    if len(s) == m: ## m이라는 길이가 되면 출력 해줘야지~
        print(' '.join(map(str, s)))# 이부분도 중요한데. s라는 리스트를 문자열로 바꾸고 그냥 쭉 합치면 된다는거지
        return

    for i in range(1, n + 1):
        if i not in s:#처음엔 빈 리스트라 아무것도 없으니 하나씩 채워주고.
          if(s==[]):
            s.append(i)## 여기가 N과M (1)에서 추가된 부분인데요 위에 보면 빈 리스트일때는 그냥 추가해주면 됩니다.
          elif(s[-1] < i):## 근데 빈 리스트가 아니라면?? 다른 조건이 필요한데, 리스트의 맨 뒷 수보다는 커야한다는거죠
            s.append(i) # 맨 뒤에 있는 숫자보다 크다면 추가를 해줍시다!( 원래는 그냥 추가했는데 까다롭게 됐네요.)
          else:
            continue## 만약에 앞에있는게 더 크면?? 그러면 그냥 쭉쭉 for 문을 돌릴 수 있도록 continue해줍시다~
          dfs()  ##이걸로 반복해서 돌면서 이미 있는것들은 빼고 없는것만 추가적으로 채워진다.
          s.pop() # n,m = 5, 3일때를 예시로 들면 처음에는 123이 나오겠지
            #그 다음엔 3을 팝 하면서 for문에 의해 4가 들어가서 124나오고 -> 125나오고 ...
            #마지막엔 542 -> 543 나오면서 마무리 되겠지


dfs()
